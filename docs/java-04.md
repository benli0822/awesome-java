# Java基础篇-04：关键字-02

## 关键字-02

### synchronized

常用与多线程编程环境，确保在同一时间内，被修饰的区域有且只有一个线程可访问控制，

#### Java中的锁机制

[原文链接](https://blog.csdn.net/u013256816/article/details/51204385)
[原文链接](https://www.cnblogs.com/darrenqiao/p/9211178.html)
[原文链接](http://youzhixueyuan.com/detailed-explanation-of-java-lock.html)

首先总结一下Java中涉及到的所有锁机制

##### 公平&非公平

| 名称     | 定义                                                                                                                                                                                   | 维度           | 优点                   | 缺点                                                                   | 性能 | 举例实现                                                                                   | 应用场景 |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------- | ---------------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------------------ | -------- |
| 公平锁   | 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。<br/> 原则：先到先得                                                                                         | 多线程执行顺序 | 保证不会出现线程饿死   | 因为先来后到排队，所以效率很低                                         |      | <code> //创建一个公平锁，构造传参true <br/>Lock fairLock= new ReentrantLock(true); </code> |          |
| 非公平锁 | 非公平锁讲究资源抢占，也就是说某个线程在某个时刻需要获取锁，并且锁也正好可用，那么线程就会直接去抢占锁资源。如果没有抢占到，则会进入阻塞队列排队。<br/> 原则：直接抢占资源，抢不到排队 | 多线程执行顺序 | 效率很明显会比公平锁高 | 抢占不到资源的线程很有可能会等待很长时间，造成阻塞队列很长或线程饿死。 |      | ```//默认构造函数创建非公平锁``` <br/>```Lock unfairLock = new ReetrantLock();```          |          |

实际使用环境中，公平锁可以看成一个FIFO的队列，请求访问资源的线程会挨个等待唤醒获取锁对需求资源进行操作。
与公平所挨个被唤醒不同的是，非公平锁会在资源控制可用，锁可用的情况下唤醒所有等待线程进行拼抢。

两者对比来说，公平锁的吞吐效率较低，整体维护阻塞线程的成本比非公平锁要高。

##### 乐观&悲观

|  名称  | 定义                                                                                                                                                       | 维度           | 优点               | 缺点                                           | 性能                               | 举例实现                 | 应用场景     |
| :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------- | :----------------- | :--------------------------------------------- | :--------------------------------- | :----------------------- | :----------- |
| 乐观锁 | **假设一定会发生并发冲突**，通过阻塞其他线程来保证数据的完整性 <br/> 原则：主动阻塞 <br/> 特征：结合数据库管理系统(DBMS)可以使用版本号机制，或者时间戳机制 | 多线程共享数据 | 效率高，           | 默认认为别人不会修改，所以不适合于写频繁的场景 | 读频繁的场景下效果好               | CAS算法                  |              |
| 悲观锁 | **假设不会发生并发冲突**，直接不加锁进行操作，如果冲突就返回失败 <br/> 原则：被动阻塞                                                                      | 多线程共享数据 | 保证写入数据一致性 | 不适合读频繁的操作场景                         | 写频繁的场景下保证数据一致性效果好 | 数据库中的行锁，表锁等。 | 操作前先上锁 |

乐观锁和悲观锁是一种广义上的概念，是不同角度上看待线程同步的不同观念。因此乐观锁和悲观锁的实现不止局限于Java中。

乐观锁的主要特点是额外控制字段：版本，时间戳等。
悲观锁的//TODO

##### 独享&共享

|  名称  | 定义                           | 维度         | 优点 | 缺点 | 性能 | 举例实现 | 应用场景 |
| :----: | :----------------------------- | :----------- | :--- | :--- | :--- | :------- | :------- |
| 独享锁 | 锁同一时间下只能有一个线程占用 | 多线程持有锁 |      |      |      |          |          |
| 共享锁 | 同时被所有线程共享持有         | 多线程持有锁 |      |      |      |          |          |



|   名称   | 定义 | 维度 | 优点 | 缺点 | 性能 | 举例实现 | 应用场景 |
| :------: | :--- | :--- | :--- | :--- | :--- | :------- | :------- |
|  自旋锁  |      |      |      |      |      |          |          |
| 可重入锁 |      |      |      |      |      |          |          |
|  偏向锁  |      |      |      |      |      |          |          |
| 轻量级锁 |      |      |      |      |      |          |          |
| 重量级锁 |      |      |      |      |      |          |          |
|  读写锁  |      |      |      |      |      |          |          |
|  互斥锁  |      |      |      |      |      |          |          |

### const


### 死锁 

死锁表现的是一种多方竞争资源造成的一种相互阻塞的僵局状态。
想象一下十字路口信号灯损坏造成堵塞的情况，如果没有交警介入，早高峰的时候将会造成重大堵塞并持续往外部蔓延。

类比交通阻塞的情况，以Java程序为例，我们考量多线程运行环境下造成死锁的情况。

![java-04-dead-lock](/img/java-04-dead-lock.png)

我们使用两个线程：Thread A, Thread B，并创建两个锁资源Lock A, Lock B来模拟上图场景。

1. 首先让Thread A获取Lock A，Thread B获取Lock B，这个动作同时发起。
2. 接着让Thread A获取Lock B，Thread B获取Lock A，这个动作同时发起。

[DeadLockDemo.java](/java/DeadLockDemo.java)

从以上程序分析，造成死锁的原因是因为线程AB各自占有锁AB，并在未释放的情况下想去获取对方手上的锁，进而造成死锁。

#### Windows内对死锁的分析监控

按照执行步骤操作。
通过编译执行java程序获得死锁。
接着另起一个窗口，获取进程PID，并通过jstack可以获得程序执行过程中详细的信息。



```CMD
-- Console 1 执行程序创建死锁
cd ./java
javac DeadLockDemo.java
java DeadLockDemo

-- Console 2 通过jstack检测查看死锁信息
tasklist | find /i "java.exe"
jstack -p 17940
```

```CMD
Found one Java-level deadlock:
=============================
"Thread B":
  waiting to lock monitor 0x00000000058b91f8 (object 0x0000000780aefc38, a java.lang.Object),
  which is held by "Thread A"
"Thread A":
  waiting to lock monitor 0x00000000058bbb38 (object 0x0000000780aefc48, a java.lang.Object),
  which is held by "Thread B"

Java stack information for the threads listed above:
===================================================
"Thread B":
        at DeadLockDemo$2.run(DeadLockDemo.java:52)
        - waiting to lock <0x0000000780aefc38> (a java.lang.Object)
        - locked <0x0000000780aefc48> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:748)
"Thread A":
        at DeadLockDemo$1.run(DeadLockDemo.java:29)
        - waiting to lock <0x0000000780aefc48> (a java.lang.Object)
        - locked <0x0000000780aefc38> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```

参考
[在Windows下，利用tasklist與taskkill來刪除Process](https://blog.twtnn.com/2013/11/windowstasklisttaskkillprocess.html)

#### 死锁出现的原因

归根结底，出现死锁的原因归结于出现阻塞。造成阻塞的原因可能是：

- 资源
  - 对不可剥夺资源的独占，导致其他等待的进程出现死锁。比方说打印机的使用。
- 执行次序
  - 对竞争临时资源使用的顺序不恰当，比方说强制占用缓存，CPU并且不释放。比方说本例中的Java程序。

#### 死锁产生的条件

产生死锁的必要条件：

- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

[死锁面试题（什么是死锁，产生死锁的原因及必要条件）](https://blog.csdn.net/hd12370/article/details/82814348 )

#### 常见避免死锁的算法

##### 预防死锁

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）