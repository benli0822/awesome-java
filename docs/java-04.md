# Java基础篇-04：关键字-02

## 关键字-02

### synchronized

常用与多线程编程环境，确保在同一时间内，被修饰的区域有且只有一个线程可访问控制，

#### Java中的锁机制

[原文链接](https://blog.csdn.net/u013256816/article/details/51204385)
[原文链接](https://www.cnblogs.com/darrenqiao/p/9211178.html)
[原文链接](http://youzhixueyuan.com/detailed-explanation-of-java-lock.html)

首先总结一下Java中涉及到的所有锁机制

##### 公平&非公平

| 名称     | 定义                                                                                                                                                                                   | 维度           | 优点                   | 缺点                                                                   | 性能 | 举例实现                                                                                   | 应用场景 |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------- | ---------------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------------------ | -------- |
| 公平锁   | 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。<br/> 原则：先到先得                                                                                         | 多线程执行顺序 | 保证不会出现线程饿死   | 因为先来后到排队，所以效率很低                                         |      | <code> //创建一个公平锁，构造传参true <br/>Lock fairLock= new ReentrantLock(true); </code> |          |
| 非公平锁 | 非公平锁讲究资源抢占，也就是说某个线程在某个时刻需要获取锁，并且锁也正好可用，那么线程就会直接去抢占锁资源。如果没有抢占到，则会进入阻塞队列排队。<br/> 原则：直接抢占资源，抢不到排队 | 多线程执行顺序 | 效率很明显会比公平锁高 | 抢占不到资源的线程很有可能会等待很长时间，造成阻塞队列很长或线程饿死。 |      | ```//默认构造函数创建非公平锁``` <br/>```Lock unfairLock = new ReetrantLock();```          |          |

实际使用环境中，公平锁可以看成一个FIFO的队列，请求访问资源的线程会挨个等待唤醒获取锁对需求资源进行操作。
与公平所挨个被唤醒不同的是，非公平锁会在资源控制可用，锁可用的情况下唤醒所有等待线程进行拼抢。

两者对比来说，公平锁的吞吐效率较低，整体维护阻塞线程的成本比非公平锁要高。

##### 乐观&悲观

|  名称  | 定义                                                                                                                                                       | 维度           | 优点               | 缺点                                           | 性能                               | 举例实现                 | 应用场景     |
| :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------- | :----------------- | :--------------------------------------------- | :--------------------------------- | :----------------------- | :----------- |
| 乐观锁 | **假设一定会发生并发冲突**，通过阻塞其他线程来保证数据的完整性 <br/> 原则：主动阻塞 <br/> 特征：结合数据库管理系统(DBMS)可以使用版本号机制，或者时间戳机制 | 多线程共享数据 | 效率高，           | 默认认为别人不会修改，所以不适合于写频繁的场景 | 读频繁的场景下效果好               | CAS算法                  |              |
| 悲观锁 | **假设不会发生并发冲突**，直接不加锁进行操作，如果冲突就返回失败 <br/> 原则：被动阻塞                                                                      | 多线程共享数据 | 保证写入数据一致性 | 不适合读频繁的操作场景                         | 写频繁的场景下保证数据一致性效果好 | 数据库中的行锁，表锁等。 | 操作前先上锁 |

乐观锁和悲观锁是一种广义上的概念，是不同角度上看待线程同步的不同观念。因此乐观锁和悲观锁的实现不止局限于Java中。

乐观锁的主要特点是额外控制字段：版本，时间戳等。
悲观锁的//TODO

##### 独享&共享

|  名称  | 定义                           | 维度         | 优点 | 缺点 | 性能 | 举例实现 | 应用场景 |
| :----: | :----------------------------- | :----------- | :--- | :--- | :--- | :------- | :------- |
| 独享锁 | 锁同一时间下只能有一个线程占用 | 多线程持有锁 |      |      |      |          |          |
| 共享锁 | 同时被所有线程共享持有         | 多线程持有锁 |      |      |      |          |          |



|   名称   | 定义 | 维度 | 优点 | 缺点 | 性能 | 举例实现 | 应用场景 |
| :------: | :--- | :--- | :--- | :--- | :--- | :------- | :------- |
|  自旋锁  |      |      |      |      |      |          |          |
| 可重入锁 |      |      |      |      |      |          |          |
|  偏向锁  |      |      |      |      |      |          |          |
| 轻量级锁 |      |      |      |      |      |          |          |
| 重量级锁 |      |      |      |      |      |          |          |
|  读写锁  |      |      |      |      |      |          |          |
|  互斥锁  |      |      |      |      |      |          |          |

### const


### 死锁 

死锁表现的是一种多方竞争资源造成的一种相互阻塞的僵局状态。
想象一下十字路口信号灯损坏造成堵塞的情况，如果没有交警介入，早高峰的时候将会造成重大堵塞并持续往外部蔓延。

类比交通阻塞的情况，以Java程序为例，我们考量多线程运行环境下造成死锁的情况。

![java-04-dead-lock](/img/java-04-dead-lock.png)

我们使用两个线程：Thread A, Thread B，并创建两个锁资源Lock A, Lock B来模拟上图场景。

1. 首先让Thread A获取Lock A，Thread B获取Lock B，这个动作同时发起。
2. 接着让Thread A获取Lock B，Thread B获取Lock A，这个动作同时发起。

